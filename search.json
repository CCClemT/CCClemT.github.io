[{"title":"判断sql注入点","url":"/2023/05/13/%E5%88%A4%E6%96%ADsql%E6%B3%A8%E5%85%A5%E7%82%B9/","content":"判断注入点判断关键\n判断该访问目标URL是否存在SQL注入?\n如果存在SQL注入，那么属于哪种SQL注入?\n\n\n只要是带有参数的动态网页且此网页访问了数据库，那么就有可能存在SQL注入\n\n判断方法\n单引号判断法\n\n​\t\t如果页面返回错误，则存在SQL注入。\n​\t\t原因是无论字符型还是整型都会因为单引号个数不匹配而报错。\n判断注入类型通常SQL注入分为两种:数字型、字符型\n\n\n本节中测试均以该表为原型\n\n数字型通常语句类型为select * from &lt;表名&gt; where id = x\n通常构造 and 1=1以及and 1=2来判断\n\n测试\n\n​\t1. select * from test where id=1 and 1=1;\n​\t\t\t\t\t\n​\t\t\t2. select * from test where id=1 and 1=2;\n\n字符型通常语句类型为select * from &lt;表名&gt; where id = &#39;x&#39;\n通常构造and &#39;1&#39;=&#39;1以及and &#39;1&#39;=&#39;2来判断\n\n测试\n\n​\t\t\t1. select * from test where gender = &#39;M&#39;and&#39;1&#39;=&#39;1&#39;;\n​\t\t\t\t\t\t\t\t\n​\t\t\t2. select * from test where gender = &#39;M&#39;and&#39;1&#39;=&#39;2&#39;;\n\n\n靶场测试\nbWAPP靶场\n\n测试过程\n https://bwapp.exp-9.com/sqli_1.php?title=t&amp;action=search\n\n由URL可知注入类型为字符型；\n尝试直接在搜索框进行测试:\n\n​\t\t&#39;t&#39; and &#39;1&#39;=&#39;1 #\n\n\n出现错误,修改后再尝试：\n\n​\t\tt%&#39; and &#39;1&#39; = &#39;1&#39; #\n\n\n成功了接下来探究原因。\n\n探究原因打开对应的php文件,贴出关键代码\n&lt;?phpif(isset($_GET[&quot;title&quot;]))&#123;    $title = $_GET[&quot;title&quot;];    $sql = &quot;SELECT * FROM movies WHERE title LIKE &#x27;%&quot; . sqli($title) . &quot;%&#x27;&quot;;    $recordset = mysqli_query($link,$sql);    if(!$recordset)    &#123;        // die(&quot;Error: &quot; . mysql_error());?&gt;\n\n可以看出，此处使用了like语法,需要闭合**’%’**并把后面不需要的内容给注释掉，综合以上得出t%&#39; and &#39;1&#39; = &#39;1&#39; #。\n注:\n\nSQL LIKE 操作符\n\nLIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。\n\nSQL LIKE 语法\n\nSELECT column1, column2, ...FROM table_nameWHERE column LIKE pattern;\n\n参数说明：\n\n**column1, column2, **：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。\n\ntable_name：要查询的表名称。\n\ncolumn：要搜索的字段名称。\n\npattern：搜索模式。\n\n‘%a’   &#x2F;&#x2F;以a结尾的数据\n‘a%’   &#x2F;&#x2F;以a开头的数据\n‘%a%’   &#x2F;&#x2F;含有a的数据\n‘_a_’   &#x2F;&#x2F;三位且中间字母是a的\n‘_a’   &#x2F;&#x2F;两位且结尾字母是a的\n‘a_’   &#x2F;&#x2F;两位且开头字母是a的\n\n\n\n\n","categories":["CTF-WEB"],"tags":["sql注入"]},{"title":"HTTP头注入","url":"/2023/06/27/HTTP%E5%A4%B4%E6%B3%A8%E5%85%A5/","content":"HTTP头注入定义针对HTTP的请求头，如果不加以过滤或者转义，在直接与数据库交互的过程中容易被利用进行SQL注入攻击，即HTTP头注入。\n\n常见场景：访问Web Server时，Web Server会从HTTP Header中取出浏览器信息、IP地址、HOST信息等存储到数据库中。\n\n实例测试\n\n前提观察:无任何输入点，回显有访问时间，IP地址，以及User-Agent。\n\n使用BP抓包拦截。\n尝试修改User-Agent观察是否有修改，\n\n发现回显修改了，推测服务器直接从User-Agent取值然后存入数据库中，尝试判断是否存在注入点。\n\n通过单引号闭合’发现报错。\n现在查看一下后端代码：\n\n贴出关键代码段\n\n$ip_address = $_SERVER[&quot;REMOTE_ADDR&quot;];$user_agent = $_SERVER[&quot;HTTP_USER_AGENT&quot;];// Writes the entry into the database$sql = &quot;INSERT INTO visitors (date, user_agent, ip_address) VALUES (now(), &#x27;&quot; . sqli($user_agent) . &quot;&#x27;, &#x27;&quot; . $ip_address . &quot;&#x27;)&quot;;$recordset = $link-&gt;query($sql);if(!$recordset)&#123;    die(&quot;Error: &quot; . $link-&gt;error);&#125;\n\n可以发现服务器的操作是通过 INSERT INTO VALUES 语句ip_address 和 user-agent 插入数据库中且第一个参数为user-agent，第二个为ip_address。\n由此我们开始构造注入语句:\nhack&#x27;,(selectdatabase()));#\n\n\n成功注入。\n","categories":["CTF-WEB"],"tags":["sql注入"]},{"title":"报错注入","url":"/2023/07/07/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","content":"报错注入(Error based Injection)定义一种SQL注入的类型，用于使SQL语句报错的语法，用于注入结果无回显但错误信息有输出的情况。\n返回的错误信息即是攻击者需要的信息。\n分类\nBigInt等数据类型溢出；\nXpath语法错误；\ncount() + rand() + groud_by() 导致重复(主键冲突)；\n空间数据类型函数错误\n\n等…\n\n常用函数：\nfloor函数;\nextractvalue函数；（最多32字符）\nupdatexml函数；\nexp()函数；\n\n\nrand([N])返回一个一个随机浮点数v，范围是0&lt;&#x3D;v&lt;1.0\nN是可选提供的，如果提供了N，则会设定N为一个SEED。\n\n可以看到在不设置种子的情况下两次的值都不同；\n\n而在设置种子均为 0 的情况下，rand()函数返回的随机序列相同。\nfloor(x)返回不大于x的最大整数\n\ncount(x)返回x数据集的数量\n\ngroup by用于结合聚合函数，根据一个或多个列对结果集进行分组。\n\n\nextractvalue(目标xml文档，xml路径)对XML文档进行查询的函数。\nxml格式\n&lt;a&gt;\t&lt;b&gt;x&lt;/b&gt;    &lt;c&gt;123&lt;/c&gt;&lt;/a&gt;\n\n‘x’的路径：&#x2F;a&#x2F;b ; ‘123’的路径：&#x2F;a&#x2F;c\nupdatexml(目标xml文档，xml路径，更新的内容)updatexml()函数与extractvalue()函数类似，都是对xml文档进行操作。只不过updatexml()是更新文档的函数。\n报错函数floor报错（测试数据库版本为5.7.26）payload:\nselect count(*),concat(user(),floor(rand(0)*2))x from table_name group by x;--+\n\n\n原理(具体参考[此处](MySQL floor()报错原理分析 - FreeBuf网络安全行业门户))总结一下就是rand()函数会在group by 函数在临时表插入原先没有的数据的时候再运行一次，从而导致插入主键于原来有的主键冲突。\n由于floor(rand(0)*2)产生的固定序列的性质，表中必须至少存在三条数据才能产生报错，根据文章内容，若将rand(0)改为__rand(14)__便能突破这一限制，使得仅需两条数据就能产生报错。\n值得一提的是，当我更改MySQL数据库的版本至8.0.32时不出现报错：\n\n推测此版本修复了该内容，至于从什么时候开始并不清楚。\nXpath报错extractvalue()报错函数的第二个参数是可以进行操作的地方，xml文件中查询使用的是&#x2F;xx&#x2F;xx&#x2F;的格式，如果我们写成其他的格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法格式的内容就是我们想要查询的内容。\npayload:\nselect extractvalue(null,concat(0x7e,(select @@version),0x7e));--+\n\n\n或\nselect extractvalue(null,concat(0x5c,(select @@version),0x5c));--+\n\n\n\n第二个逗号后的0x7e(5c)可有可无\n\n原理使用extractvalue函数时，路径的正确格式为&#x2F;xxx&#x2F;xxx&#x2F;而0x7e(‘~’)和0x5c(‘\\‘),从而使得sql语句变得非法。\nupdatexml()报错updatexml()报错与extractvalue()报错原理相同，且都是对第二个参数即xml路径进行操作。\nselect updatexml(1,concat(0x5c,(select database()),0x5c),1);--+\n\n","categories":["CTF-WEB"],"tags":["sql注入"]}]