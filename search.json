[{"title":"判断sql注入点","url":"/2023/05/13/%E5%88%A4%E6%96%ADsql%E6%B3%A8%E5%85%A5%E7%82%B9/","content":"判断注入点判断关键\n判断该访问目标URL是否存在SQL注入?\n如果存在SQL注入，那么属于哪种SQL注入?\n\n\n只要是带有参数的动态网页且此网页访问了数据库，那么就有可能存在SQL注入\n\n判断方法\n单引号判断法\n\n​\t\t如果页面返回错误，则存在SQL注入。\n​\t\t原因是无论字符型还是整型都会因为单引号个数不匹配而报错。\n判断注入类型通常SQL注入分为两种:数字型、字符型\n\n\n本节中测试均以该表为原型\n\n数字型通常语句类型为select * from &lt;表名&gt; where id = x\n通常构造 and 1=1以及and 1=2来判断\n\n测试\n\n​\t1. select * from test where id=1 and 1=1;\n​\t\t\t\t\t\n​\t\t\t2. select * from test where id=1 and 1=2;\n\n字符型通常语句类型为select * from &lt;表名&gt; where id = &#39;x&#39;\n通常构造and &#39;1&#39;=&#39;1以及and &#39;1&#39;=&#39;2来判断\n\n测试\n\n​\t\t\t1. select * from test where gender = &#39;M&#39;and&#39;1&#39;=&#39;1&#39;;\n​\t\t\t\t\t\t\t\t\n​\t\t\t2. select * from test where gender = &#39;M&#39;and&#39;1&#39;=&#39;2&#39;;\n\n\n靶场测试\nbWAPP靶场\n\n测试过程\n https://bwapp.exp-9.com/sqli_1.php?title=t&amp;action=search\n\n由URL可知注入类型为字符型；\n尝试直接在搜索框进行测试:\n\n​\t\t&#39;t&#39; and &#39;1&#39;=&#39;1 #\n\n\n出现错误,修改后再尝试：\n\n​\t\tt%&#39; and &#39;1&#39; = &#39;1&#39; #\n\n\n成功了接下来探究原因。\n\n探究原因打开对应的php文件,贴出关键代码\n&lt;?phpif(isset($_GET[&quot;title&quot;]))&#123;    $title = $_GET[&quot;title&quot;];    $sql = &quot;SELECT * FROM movies WHERE title LIKE &#x27;%&quot; . sqli($title) . &quot;%&#x27;&quot;;    $recordset = mysqli_query($link,$sql);    if(!$recordset)    &#123;        // die(&quot;Error: &quot; . mysql_error());?&gt;\n\n可以看出，此处使用了like语法,需要闭合**’%’**并把后面不需要的内容给注释掉，综合以上得出t%&#39; and &#39;1&#39; = &#39;1&#39; #。\n注:\n\nSQL LIKE 操作符\n\nLIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。\n\nSQL LIKE 语法\n\nSELECT column1, column2, ...FROM table_nameWHERE column LIKE pattern;\n\n参数说明：\n\n**column1, column2, **：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。\n\ntable_name：要查询的表名称。\n\ncolumn：要搜索的字段名称。\n\npattern：搜索模式。\n\n‘%a’   &#x2F;&#x2F;以a结尾的数据\n‘a%’   &#x2F;&#x2F;以a开头的数据\n‘%a%’   &#x2F;&#x2F;含有a的数据\n‘_a_’   &#x2F;&#x2F;三位且中间字母是a的\n‘_a’   &#x2F;&#x2F;两位且结尾字母是a的\n‘a_’   &#x2F;&#x2F;两位且开头字母是a的\n\n\n\n\n","categories":["CTF-WEB"],"tags":["sql注入"]},{"title":"HTTP头注入","url":"/2023/06/27/HTTP%E5%A4%B4%E6%B3%A8%E5%85%A5/","content":"HTTP头注入定义针对HTTP的请求头，如果不加以过滤或者转义，在直接与数据库交互的过程中容易被利用进行SQL注入攻击，即HTTP头注入。\n\n常见场景：访问Web Server时，Web Server会从HTTP Header中取出浏览器信息、IP地址、HOST信息等存储到数据库中。\n\n实例测试\n\n前提观察:无任何输入点，回显有访问时间，IP地址，以及User-Agent。\n\n使用BP抓包拦截。\n尝试修改User-Agent观察是否有修改，\n\n发现回显修改了，推测服务器直接从User-Agent取值然后存入数据库中，尝试判断是否存在注入点。\n\n通过单引号闭合’发现报错。\n现在查看一下后端代码：\n\n贴出关键代码段\n\n$ip_address = $_SERVER[&quot;REMOTE_ADDR&quot;];$user_agent = $_SERVER[&quot;HTTP_USER_AGENT&quot;];// Writes the entry into the database$sql = &quot;INSERT INTO visitors (date, user_agent, ip_address) VALUES (now(), &#x27;&quot; . sqli($user_agent) . &quot;&#x27;, &#x27;&quot; . $ip_address . &quot;&#x27;)&quot;;$recordset = $link-&gt;query($sql);if(!$recordset)&#123;    die(&quot;Error: &quot; . $link-&gt;error);&#125;\n\n可以发现服务器的操作是通过 INSERT INTO VALUES 语句ip_address 和 user-agent 插入数据库中且第一个参数为user-agent，第二个为ip_address。\n由此我们开始构造注入语句:\nhack&#x27;,(selectdatabase()));#\n\n\n成功注入。\n","categories":["CTF-WEB"],"tags":["sql注入"]}]